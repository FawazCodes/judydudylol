<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="color-scheme" content="light dark" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="format-detection" content="telephone=no" />
  <title>جود!</title>

  <!-- Favicons -->
  <link rel="icon" href="favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="mask-icon" href="safari-pinned-tab.svg" color="#7c3aed">
  <meta name="theme-color" content="#0b0d12" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#f6f7fb" media="(prefers-color-scheme: light)">

  <!-- Preload critical assets with priority -->
  <link rel="preload" href="drift.png" as="image" type="image/png" fetchpriority="high">
  <link rel="preload" href="drift2.png" as="image" type="image/png" fetchpriority="high">
  <link rel="preload" href="keko.mp3" as="audio" type="audio/mpeg">
  <link rel="preload" href="falafel.mp3" as="audio" type="audio/mpeg">

  <style>
    :root{
      --bg:#0b0d12; --fg:#e5e7eb; --muted:#94a3b8;
      --a:#7c3aed; --b:#10b981; --c:#f59e0b; --d:#06b6d4; --e:#e11d48; --f:#a3e635;
      --touch-target: 44px;
      --border-radius: 12px;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
      --shadow-lg: 0 20px 40px rgba(0,0,0,.3);
      
      /* Enhanced Design System */
      --shadow-sm: 0 2px 8px rgba(0,0,0,.15);
      --shadow-md: 0 8px 25px rgba(0,0,0,.2);
      --shadow-xl: 0 25px 50px rgba(0,0,0,.35);
      --shadow-inner: inset 0 2px 4px rgba(0,0,0,.1);
      
      /* Semantic Colors */
      --success: #10b981;
      --warning: #f59e0b;
      --error: #e11d48;
      --info: #06b6d4;
      
      /* Enhanced Spacing */
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
      
      /* Transitions */
      --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      
      /* Z-index layers */
      --z-base: 1;
      --z-overlay: 10;
      --z-modal: 100;
      --z-tooltip: 200;

      /* Button Specific Vars */
      --primary: #7c3aed;
      --secondary: #10b981;
      --accent: #f59e0b;
      --tertiary: #06b6d4;
      --quaternary: #e11d48;
      --text-light: #ffffff;
      --transition-smooth: 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f6f7fb; --fg:#0b0d12; --muted:#475569;
        --shadow: 0 10px 30px rgba(0,0,0,.15);
        --shadow-lg: 0 20px 40px rgba(0,0,0,.2);
      }
    }

    *{ box-sizing:border-box }
    html,body{ margin:0; height:100% }
    body{
      background: var(--bg);
      color:var(--fg);
      font:16px/1.5 ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Apple Color Emoji, Segoe UI Emoji, sans-serif;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      touch-action:manipulation; user-select:none;
      overflow: hidden;
      /* iOS optimizations */
      -webkit-overflow-scrolling: touch;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      position: relative;
    }
    
    .wrap{
      height:100%;
      display:grid;
      place-items:center;
      padding:var(--spacing-lg);
      position: relative;
      z-index: var(--z-overlay);
      transition: all var(--transition-slow);
      opacity: 1;
      transform: scale(1);
    }
    
    .wrap.hidden {
      opacity: 0;
      transform: scale(0.95);
      pointer-events: none;
    }
    
    .wrap.entering {
      animation: wrapEntrance 0.8s ease-out;
    }
    
    @keyframes wrapEntrance {
      0% { 
        opacity: 0; 
        transform: scale(0.8) translateY(30px);
      }
      100% { 
        opacity: 1; 
        transform: scale(1) translateY(0);
      }
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-md);
      z-index: var(--z-overlay);
      transition: all var(--transition-normal);
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(10px);
      padding: var(--spacing-xl);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-xl);
      border: 1px solid rgba(255,255,255,0.1);
    }

    .loading.hidden {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.9);
      pointer-events: none;
      z-index: -1;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(124,58,237,0.2);
      border-top: 4px solid var(--a);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      box-shadow: var(--shadow-lg);
    }
    
    .loading-progress {
      width: 200px;
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }
    
    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--a), var(--b));
      border-radius: 3px;
      width: 0%;
      transition: width var(--transition-normal);
      box-shadow: 0 0 10px rgba(124,58,237,0.5);
    }
    
    .loading-text {
      color: var(--fg);
      font-weight: 600;
      font-size: 14px;
      text-align: center;
      opacity: 0.8;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* --- Base Button Styles --- */
    .hybrid-base {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-height: 70px;
        width: 220px;
        padding: 22px 44px;
        font-weight: 800;
        font-size: 19px;
        letter-spacing: 0.5px;
        border-radius: 20px;
        cursor: pointer;
        color: var(--text-light);
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        transition: all var(--transition-smooth);
        transform-style: preserve-3d;
        transform: translateZ(0) rotateX(0deg) rotateY(0deg);
        will-change: transform, box-shadow, background;
        overflow: hidden;
        border: none;
    }

    /* Variation 2: Glitched Orb */
    .hybrid-merge-1 {
        width: 140px;
        height: 140px;
        min-height: auto;
        padding: 0;
        background: rgba(124, 58, 237, 0.2);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        animation: liquidMorph 12s ease-in-out infinite alternate;
        border: 1px solid rgba(124, 58, 237, 0.5);
    }
    .hybrid-merge-1 .text {
        transition: all 0.2s;
    }
    .hybrid-merge-1:hover .text {
        animation: glitch 0.5s steps(3, end) infinite;
        text-shadow: -3px 0 var(--secondary), 3px 0 var(--quaternary);
    }

    @keyframes liquidMorph {
        0%, 100% { border-radius: 42% 58% 70% 30% / 45% 45% 55% 55%; }
        25% { border-radius: 58% 42% 30% 70% / 55% 55% 45% 45%; }
        50% { border-radius: 30% 70% 42% 58% / 45% 45% 55% 55%; }
        75% { border-radius: 70% 30% 58% 42% / 55% 55% 45% 45%; }
    }

    @keyframes glitch {
        0% { transform: translate(0); }
        20% { transform: translate(-3px, 3px); }
        40% { transform: translate(-3px, -3px); }
        60% { transform: translate(3px, 3px); }
        80% { transform: translate(3px, -3px); }
        100% { transform: translate(0); }
    }

    .play{
      position:fixed;
      inset:0;
      display:none;
      overflow:hidden;
      backface-visibility:hidden;
      /* Hardware acceleration */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      will-change: transform;
      opacity: 0;
      transform: scale(1.05);
      transition: all var(--transition-slow);
    }
    
    .play.visible {
      opacity: 1;
      transform: scale(1);
    }

    .play.paused{ 
      filter:saturate(.8) brightness(.9);
      animation: pausePulse 2s ease-in-out infinite;
    }
    
    @keyframes pausePulse {
      0%, 100% { filter: saturate(.8) brightness(.9); }
      50% { filter: saturate(.7) brightness(.85); }
    }

    .canvas-container {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .canvas-container canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    #backgroundCanvas { z-index: 1; }
    #tireMarkCanvas { z-index: 2; }
    #mainCanvas { z-index: 4; }


    .drifter{
      position:absolute;
      left:0;
      top:0;
      width:min(38vw, 420px);
      transform:translate(-1000px,-1000px) rotate(0deg);
      will-change:transform;
      pointer-events:none;
      user-select:none;
      filter: drop-shadow(0 10px 24px rgba(0,0,0,.35));
      z-index:3;
      opacity:.95;
      /* Hardware acceleration */
      -webkit-transform: translate3d(-1000px,-1000px,0) rotate(0deg);
      transform: translate3d(-1000px,-1000px,0) rotate(0deg);
    }

    .smirk{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%) scale(.2);
      font-size:110px;
      filter:drop-shadow(0 6px 18px rgba(0,0,0,.3));
      opacity:0;
      z-index:5;
      pointer-events:none;
      /* Hardware acceleration */
      -webkit-transform: translate3d(-50%,-50%,0) scale(.2);
      transform: translate3d(-50%,-50%,0) scale(.2);
      will-change: transform;
    }

    .flash{
      position:absolute;
      inset:0;
      background:linear-gradient(180deg, rgba(255,255,255,.15), transparent);
      opacity:0;
      pointer-events:none;
      transition:opacity .2s ease;
      z-index:6;
    }

    .smirk.show{ animation:smirkIn .6s cubic-bezier(.2,.9,.2,1) forwards }

    @keyframes smirkIn{
      to{
        -webkit-transform:translate3d(-50%,-50%,0) scale(1);
        transform:translate3d(-50%,-50%,0) scale(1);
        opacity:1
      }
    }

    .flash.show{ opacity:1 }

    .shake{ animation:shake .28s linear 1 }

    @keyframes shake{
      0%,100%{ -webkit-transform:translate3d(0,0,0); transform:translate3d(0,0,0) }
      25%{ -webkit-transform:translate3d(2px,-2px,0); transform:translate3d(2px,-2px,0) }
      50%{ -webkit-transform:translate3d(-2px,2px,0); transform:translate3d(-2px,2px,0) }
      75%{ -webkit-transform:translate3d(2px,2px,0); transform:translate3d(2px,2px,0) }
    }

    .bump{ animation:bump .1s ease-out 1 }

    @keyframes bump{
      from{ -webkit-transform:scale3d(.985,1,1); transform:scale3d(.985,1,1) }
      to{ -webkit-transform:scale3d(1,1,1); transform:scale3d(1,1,1) }
    }
    
    /* Enhanced interaction feedback */
    .interaction-feedback {
      position: absolute;
      pointer-events: none;
      z-index: var(--z-tooltip);
      animation: feedbackPop 0.3s ease-out forwards;
    }
    
    @keyframes feedbackPop {
      0% { 
        opacity: 0; 
        transform: scale(0.5) translateY(10px);
      }
      50% { 
        opacity: 1; 
        transform: scale(1.1) translateY(-5px);
      }
      100% { 
        opacity: 0; 
        transform: scale(1) translateY(-10px);
      }
    }
    
    .skeleton, .skeleton-loading {
      background: linear-gradient(90deg,
        rgba(124,58,237,0.1) 25%,
        rgba(124,58,237,0.2) 50%,
        rgba(124,58,237,0.1) 75%);
      background-size: 200% 100%;
      animation: loading 1.5s infinite;
      border-radius: var(--border-radius);
    }
    
    .skeleton-button {
      width: 200px;
      height: 60px;
      border-radius: 999px;
    }
    
    .skeleton-text {
      width: 120px;
      height: 20px;
      margin: var(--spacing-sm) 0;
    }

    /* Enhanced Mobile Responsiveness */
    @media (max-width: 768px) {
      .smirk { font-size: 80px; }
      .drifter {
        width: min(57vw, 630px);
      }
      .wrap {
        padding: var(--spacing-md);
      }
      .hybrid-base {
        min-height: 60px;
        width: 180px;
        padding: 18px 36px;
        font-size: 17px;
      }
      .hybrid-merge-1 {
        width: 120px;
        height: 120px;
      }
    }

    @media (max-width: 480px) {
      .smirk { font-size: 60px; }
      .wrap {
        padding: var(--spacing-sm);
      }
      .hybrid-base {
        min-height: 56px;
        width: 160px;
        padding: 16px 32px;
        font-size: 16px;
      }
      .hybrid-merge-1 {
        width: 100px;
        height: 100px;
      }
    }

    /* Orientation Handling */
    @media (orientation: landscape) and (max-height: 500px) {
      .wrap {
        padding: var(--spacing-sm);
      }
      .hybrid-base {
        min-height: 50px;
        padding: 14px 28px;
        font-size: 15px;
      }
      .smirk {
        font-size: 50px;
      }
    }

    /* Touch Target Accessibility */
    .hybrid-base {
      min-height: 44px; /* Minimum touch target size */
      touch-action: manipulation;
    }

    /* High DPI Display Support */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      .drifter {
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }
    }
    
    @media (prefers-reduced-motion: reduce) {
      .hybrid-base {
        animation: none;
        transition: all 0.2s ease;
      }
    }

    .sr-only{
      position:absolute; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
    }

    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    @keyframes rippleExpand {
      0% { 
        width: 0; 
        height: 0; 
        opacity: 1;
      }
      100% { 
        width: 200px; 
        height: 200px; 
        opacity: 0;
      }
    }

    @keyframes pinchFeedback {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.5);
      }
      50% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.2);
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1) translateY(-20px);
      }
    }

    /* Enhanced Visual Effects */
    .enhanced-feedback {
      position: absolute;
      pointer-events: none;
      z-index: var(--z-tooltip);
      animation: enhancedFeedback 0.6s ease-out forwards;
    }

    @keyframes enhancedFeedback {
      0% { 
        opacity: 0; 
        transform: scale(0.3) rotate(0deg);
      }
      50% { 
        opacity: 1; 
        transform: scale(1.1) rotate(180deg);
      }
      100% { 
        opacity: 0; 
        transform: scale(1) rotate(360deg) translateY(-30px);
      }
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <div class="loading-progress">
      <div class="loading-progress-bar" id="loadingProgress"></div>
    </div>
    <div class="loading-text" id="loadingText">جاري التحميل...</div>
  </div>

  <div class="wrap" id="wrap">
    <div class="skeleton-loading skeleton-button" id="skeletonButton"></div>
    <button class="hybrid-base hybrid-merge-1" id="startBtn" aria-label="Start" tabindex="0" role="button" style="display: none;"><span class="text">اضغط هنا</span></button>
  </div>

  <main class="play" id="play" aria-label="Play field" tabindex="0">
    <div class="canvas-container">
      <canvas id="backgroundCanvas"></canvas>
      <canvas id="tireMarkCanvas"></canvas>
      <canvas id="mainCanvas"></canvas>
    </div>
    <img id="drifter" class="drifter" src="drift.png" alt="" />
    <div class="smirk" id="smirk" aria-hidden="true">😝</div>
    <div class="flash" id="flash"></div>
    <p id="srHelp" class="sr-only" aria-live="polite"></p>
  </main>

  <!-- Audio with preload and compression -->
  <audio id="sfxKeko" src="keko.mp3" preload="auto" playsinline></audio>
  <audio id="bgMusic" src="falafel.mp3" preload="auto" playsinline loop></audio>

<script>
(()=>{
  // Elements
  const wrap = document.getElementById('wrap');
  const startBtn = document.getElementById('startBtn');
  const skeletonButton = document.getElementById('skeletonButton');
  const play = document.getElementById('play');
  const smirk = document.getElementById('smirk');
  const flash = document.getElementById('flash');
  const drifter = document.getElementById('drifter');
  const sfxKeko = document.getElementById('sfxKeko');
  const srHelp = document.getElementById('srHelp');
  const loading = document.getElementById('loading');
  const loadingProgress = document.getElementById('loadingProgress');
  const loadingText = document.getElementById('loadingText');

  // Canvas setup
  const bgCanvas = document.getElementById('backgroundCanvas');
  const tireMarkCanvas = document.getElementById('tireMarkCanvas');
  const mainCanvas = document.getElementById('mainCanvas');
  const bgCtx = bgCanvas.getContext('2d');
  const tireMarkCtx = tireMarkCanvas.getContext('2d');
  const mainCtx = mainCanvas.getContext('2d');
  const canvases = [bgCanvas, tireMarkCanvas, mainCanvas];

  // Wheel centers measured as fractions of the image (0..1) from top-left
  const IMAGE_ANCHORS = {
    'drift.png': {                     // driver inside
      rearLeft:  { x: 0.22, y: 0.86 },
      rearRight: { x: 0.83, y: 0.88 },
      smokeFrom: 'right'
    },
    'drift2.png': {                    // leaning on door
      rearLeft:  { x: 0.20, y: 0.86 },
      rearRight: { x: 0.78, y: 0.86 },
      smokeFrom: 'left'
    }
  };

  // computed each resize
  let wheelLocalLeft = {x:0,y:0};
  let wheelLocalRight = {x:0,y:0};


  // Debug: Check if all elements are found
  console.log('DOM Elements check:', {
    wrap: !!wrap,
    startBtn: !!startBtn,
    play: !!play,
    smirk: !!smirk,
    flash: !!flash,
    drifter: !!drifter,
    sfxKeko: !!sfxKeko,
    canvases: canvases.every(c => !!c),
    srHelp: !!srHelp,
    loading: !!loading
  });

  if (!wrap || !startBtn || !play || canvases.some(c => !c) || !loading) {
    console.error('Critical DOM elements missing!');
    document.body.innerHTML = '<div style="padding: 20px; color: red;">Error: Critical elements not found. Please refresh the page.</div>';
    return;
  }

  // Query flags
  const q = new URLSearchParams(location.search);
  const forceRM = q.get('rm') === '1' || q.get('reduced') === '1';

  // Size/DPI cache
  let viewW = 0, viewH = 0, dpr = 1;
  let carWidthPx = 0, carHeightPx = 0;
  let currentDriftImage = 'drift.png';
  let driftImageSide = 'right'; // 'right' for drift.png, 'left' for drift2.png

  function updateCarMetrics(){
    const carRect = drifter.getBoundingClientRect();
    carWidthPx = carRect.width;

    const ratio = (drifter.naturalWidth > 0 && drifter.naturalHeight > 0)
      ? drifter.naturalHeight / drifter.naturalWidth : 1;
    carHeightPx = carWidthPx * ratio;

    const meta = IMAGE_ANCHORS[currentDriftImage] || IMAGE_ANCHORS['drift.png'];
    // convert from image space to car-local space centered at the image middle
    wheelLocalLeft.x  = (meta.rearLeft.x  - 0.5) * carWidthPx;
    wheelLocalLeft.y  = (meta.rearLeft.y  - 0.5) * carHeightPx;
    wheelLocalRight.x = (meta.rearRight.x - 0.5) * carWidthPx;
    wheelLocalRight.y = (meta.rearRight.y - 0.5) * carHeightPx;
  }

  function resizeAllCanvases() {
    const rect = play.getBoundingClientRect();
    dpr = window.devicePixelRatio || 1;
    viewW = rect.width;
    viewH = rect.height;
    
    canvases.forEach(canvas => {
      const ctx = canvas.getContext('2d', {
        alpha: true,
        antialias: false,
        willReadFrequently: false
      });
      canvas.width  = Math.max(1, Math.floor(rect.width  * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
      
      // Optimize context settings
      ctx.imageSmoothingEnabled = false; // Disable for better performance
      ctx.globalCompositeOperation = 'source-over';
    });
    
    updateCarMetrics();
    initStars(); // Re-initialize stars for new size
  }

  // Enhanced Global State with Memory Management
  let activeParticles = [];
  let particlePool = [];
  let lastTime = 0;
  let pressing = false;
  let pressTimer = null;
  let lastTrail = 0;
  let paused = false;
  let autoPaused = false;
  let stars = [];
  let lastTirePoints = { left: null, right: null };
  
  // Memory management and performance tracking
  let frameCount = 0;
  let lastFPS = 0;
  let memoryUsage = 0;
  let particleCreationCount = 0;
  let particleReuseCount = 0;
  
  // Enhanced particle pool with object recycling
  const PARTICLE_POOL_SIZE = 500;
  const MAX_ACTIVE_PARTICLES = 300;
  
  // Initialize particle pool
  function initializeParticlePool() {
    for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
      particlePool.push(createParticleObject());
    }
    console.log(`Initialized particle pool with ${PARTICLE_POOL_SIZE} objects`);
  }
  
  // Create reusable particle object
  function createParticleObject() {
    return {
      x: 0, y: 0, vx: 0, vy: 0, rot: 0, vrot: 0, scale: 1, opacity: 1,
      life: 0, initialLife: 0, duration: 0, size: 0, color: '#ffffff',
      text: '', src: null, spriteIndex: 0, initialSize: 0,
      update: null, render: null, active: false,
      // Add metadata for debugging
      createdAt: 0, lastUsed: 0, useCount: 0
    };
  }
  
  // Memory cleanup function
  function cleanupMemory() {
    const now = performance.now();
    const maxAge = 30000; // 30 seconds
    
    // Clean up old particles
    for (let i = activeParticles.length - 1; i >= 0; i--) {
      const p = activeParticles[i];
      if (p.life <= 0 || (now - p.createdAt > maxAge)) {
        p.active = false;
        p.useCount++;
        p.lastUsed = now;
        particlePool.push(p);
        activeParticles.splice(i, 1);
      }
    }
    
    // Limit active particles to prevent memory issues
    if (activeParticles.length > MAX_ACTIVE_PARTICLES) {
      const excess = activeParticles.length - MAX_ACTIVE_PARTICLES;
      for (let i = 0; i < excess; i++) {
        const p = activeParticles.shift();
        p.active = false;
        p.useCount++;
        p.lastUsed = now;
        particlePool.push(p);
      }
    }
    
    // Log memory usage periodically
    if (frameCount % 300 === 0) { // Every 5 seconds at 60fps
      console.log(`Memory Status: Active: ${activeParticles.length}, Pool: ${particlePool.length}, Reuse Rate: ${((particleReuseCount / (particleCreationCount + particleReuseCount)) * 100).toFixed(1)}%`);
    }
  }

  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches || forceRM;

  // Enhanced AUDIO SYSTEM with loading states
  const audio = {
    ctx: null,
    unlocked: false,
    muted: (()=> {
      const q = new URLSearchParams(location.search);
      return q.get('mute') === '1' || q.get('audio') === 'off';
    })(),
    loading: {
      sfx: false,
      bgMusic: false,
      total: 0,
      loaded: 0
    }
  };
  const sfx = { keko: sfxKeko };
  const bgMusic = document.getElementById('bgMusic');
  
  // Audio loading state management
  function updateAudioLoadingState(type, loaded) {
    if (loaded) {
      audio.loading[type] = true;
      audio.loading.loaded++;
    }
    
    const progress = (audio.loading.loaded / audio.loading.total) * 100;
    updateLoadingProgress(progress, `جاري تحميل الصوت... ${Math.round(progress)}%`);
  }
  
  // Initialize audio loading states
  audio.loading.total = 2; // sfx + bgMusic
  audio.loading.loaded = 0;
  
  // Add audio loading event listeners
  if (sfxKeko) {
    sfxKeko.addEventListener('canplaythrough', () => updateAudioLoadingState('sfx', true));
    sfxKeko.addEventListener('error', () => console.warn('SFX audio failed to load'));
  }
  
  if (bgMusic) {
    bgMusic.addEventListener('canplaythrough', () => updateAudioLoadingState('bgMusic', true));
    bgMusic.addEventListener('error', () => console.warn('Background music failed to load'));
  }
  
  // Enhanced image preloading for drift images
  function preloadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
      img.src = src;
    });
  }
  
  // Enhanced image preloading with multiple strategies
  function preloadImageWithFallback(src) {
    return new Promise((resolve, reject) => {
      // Try to use the browser's native preloading
      if ('connection' in navigator && navigator.connection.effectiveType === '4g') {
        // High-speed connection - load immediately
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
        img.src = src;
      } else {
        // Slower connection - use progressive loading
        setTimeout(() => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
          img.src = src;
        }, 100);
      }
    });
  }
  
  // Preload both drift images with enhanced strategy
  Promise.all([
    preloadImageWithFallback('drift.png'),
    preloadImageWithFallback('drift2.png')
  ]).then(() => {
    console.log('Both drift images preloaded successfully');
    // Update loading progress when images are ready
    updateLoadingProgress(75, 'تم تحميل الصور...');
  }).catch(error => {
    console.warn('Some drift images failed to preload:', error);
  });

  function initAudio(){
    if (audio.ctx) return;
    try { audio.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
    catch(e){ audio.ctx = null; }
  }
  async function unlockAudio(){
    if (audio.unlocked) return;
    initAudio();
    try {
      if (audio.ctx && audio.ctx.state === 'suspended') await audio.ctx.resume();
      if (audio.ctx) {
        const g = audio.ctx.createGain(); g.gain.value = 0; g.connect(audio.ctx.destination); g.disconnect();
      }
      audio.unlocked = true;
      if (bgMusic) {
        bgMusic.volume = 0.25;
        try { await bgMusic.play(); } catch(e) {}
      }
    } catch(e){}
  }
  function ping(){
    if (!audio.ctx) return;
    const o = audio.ctx.createOscillator();
    const g = audio.ctx.createGain();
    o.type='triangle';
    o.frequency.value=1600;
    g.gain.value=0.0001;
    const t0 = audio.ctx.currentTime;
    g.gain.exponentialRampToValueAtTime(0.18, t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.12);
    o.connect(g).connect(audio.ctx.destination);
    o.start(); o.stop(t0+0.15);
  }
  function playSfx(name){
    if (audio.muted || !audio.unlocked) return;
    const el = sfx[name];
    if (!el) return;
    try {
      el.pause(); el.currentTime = 0;
      const p = el.play(); if (p && typeof p.then === 'function') p.catch(()=>{});
    } catch(e){}
  }
  sfxKeko.addEventListener('ended', ()=>{ if (audio.unlocked) ping(); });

  // Utils
  function rand(min,max){ return Math.random()*(max-min)+min }
  function pickColor(){ const p=['#7c3aed','#10b981','#f59e0b','#06b6d4','#e11d48','#a3e635']; return p[(Math.random()*p.length)|0] }
  
  // Enhanced haptic feedback
  function haptic(){
    play.classList.add('bump'); 
    setTimeout(()=>play.classList.remove('bump'), 100);
    
    // Enhanced haptic feedback for mobile
    if (navigator.vibrate) {
      navigator.vibrate(50);
    }
    
    // Visual feedback
    createInteractionFeedback();
  }
  
  function announce(msg){ srHelp.textContent = msg; }
  
  // Create visual feedback for interactions
  function createInteractionFeedback() {
    const feedback = document.createElement('div');
    feedback.className = 'interaction-feedback';
    feedback.innerHTML = '🦗';
    feedback.style.left = Math.random() * (viewW - 100) + 50 + 'px';
    feedback.style.top = Math.random() * (viewH - 100) + 50 + 'px';
    feedback.style.fontSize = '24px';
    feedback.style.color = pickColor();
    
    play.appendChild(feedback);
    
    setTimeout(() => {
      if (feedback.parentNode) {
        feedback.parentNode.removeChild(feedback);
      }
    }, 300);
  }
  
  // Enhanced loading system
  function updateLoadingProgress(progress, text) {
    if (loadingProgress) {
      loadingProgress.style.width = progress + '%';
    }
    if (loadingText && text) {
      loadingText.textContent = text;
    }
  }
  
  // Skeleton loading management
  function showSkeleton() {
    if (skeletonButton) skeletonButton.style.display = 'block';
    if (startBtn) startBtn.style.display = 'none';
  }
  
  function hideSkeleton() {
    if (skeletonButton) skeletonButton.style.display = 'none';
    if (startBtn) startBtn.style.display = 'inline-flex';
  }

  // Pre-rendered smoke sprites with multiple variations
  const smokeSprites = [];
  (function makeSmokeSprites(){
    for(let i = 0; i < 3; i++) {
      const sprite = document.createElement('canvas');
      // 20% bigger smoke sprites
      const s = (64 + i * 16) * 1.2; 
      sprite.width = s; sprite.height = s;
      const g = sprite.getContext('2d');
      
      // Create more realistic smoke with multiple layers and better gradients
      const grad1 = g.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
      grad1.addColorStop(0, 'rgba(255,255,255,0.9)');
      grad1.addColorStop(0.2, 'rgba(240,240,240,0.7)');
      grad1.addColorStop(0.4, 'rgba(200,200,200,0.5)');
      grad1.addColorStop(0.6, 'rgba(160,160,160,0.3)');
      grad1.addColorStop(0.8, 'rgba(120,120,120,0.1)');
      grad1.addColorStop(1, 'rgba(80,80,80,0)');
      
      g.fillStyle = grad1;
      g.beginPath(); 
      // Create more irregular, realistic smoke shape
      const noise = 0.4;
      const points = 12; // More points for smoother shape
      for(let j = 0; j < points; j++) {
        const angle = (j / points) * Math.PI * 2;
        const radius = s/2 * (0.6 + Math.random() * noise);
        const x = s/2 + Math.cos(angle) * radius;
        const y = s/2 + Math.sin(angle) * radius;
        if(j === 0) g.moveTo(x, y);
        else g.lineTo(x, y);
      }
      g.closePath(); g.fill();
      
      // Add darker core for depth and realism
      const grad2 = g.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2.5);
      grad2.addColorStop(0, 'rgba(60,60,60,0.6)');
      grad2.addColorStop(0.5, 'rgba(80,80,80,0.3)');
      grad2.addColorStop(1, 'rgba(100,100,100,0)');
      g.fillStyle = grad2;
      g.beginPath(); g.arc(s/2, s/2, s/2.5, 0, Math.PI*2); g.fill();
      
      // Add subtle highlights for more realistic appearance
      const grad3 = g.createRadialGradient(s/2 - s/6, s/2 - s/6, 0, s/2 - s/6, s/2 - s/6, s/4);
      grad3.addColorStop(0, 'rgba(255,255,255,0.4)');
      grad3.addColorStop(1, 'rgba(255,255,255,0)');
      g.fillStyle = grad3;
      g.beginPath(); g.arc(s/2 - s/6, s/2 - s/6, s/4, 0, Math.PI*2); g.fill();
      
      smokeSprites.push(sprite);
    }
  })();

  // Enhanced device capability detection
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  const isLowEnd = navigator.deviceMemory && navigator.deviceMemory < 2;
  const isHighEnd = navigator.deviceMemory && navigator.deviceMemory > 6;
  const hasHighRefreshRate = window.screen && window.screen.refreshRate > 60;
  
  const quality = { 
    density: isMobile ? 0.45 : (isLowEnd ? 0.6 : 0.9), 
    heavy: !isMobile && !isLowEnd && (navigator.deviceMemory || 4) > 3,
    adaptive: true
  };
  
  const BASE_MAX = isMobile ? (isLowEnd ? 100 : 150) : (isLowEnd ? 200 : 350);
  let maxParticles = BASE_MAX;
  
  // Limit smoke particles specifically to prevent screen clutter
  const MAX_SMOKE_PARTICLES = Math.floor(maxParticles * 0.6); // Max 60% of particles can be smoke (increased from 40%)
  
  // Adaptive particle density based on performance
  function adjustParticleDensity() {
    const fps = 1 / Math.max(emaDt, 1e-6);
    
    if (fps < 45 && quality.adaptive) {
      // Reduce density for better performance
      quality.density = Math.max(0.3, quality.density * 0.9);
      maxParticles = Math.max(50, Math.floor(maxParticles * 0.85));
    } else if (fps > 58 && quality.adaptive && !isLowEnd) {
      // Increase density if performance allows
      quality.density = Math.min(1.0, quality.density * 1.05);
      maxParticles = Math.min(BASE_MAX, Math.floor(maxParticles * 1.1));
    }
  }

  function addParticle(props) {
    // Check smoke particle limits first
    if (props.render === renderSmoke) {
      const smokeCount = activeParticles.filter(part => part.active && part.render === renderSmoke).length;
      if (smokeCount >= MAX_SMOKE_PARTICLES) {
        if (Math.random() < 0.05) { // 5% chance to log
          console.log('Smoke particle limit reached:', smokeCount, '>=', MAX_SMOKE_PARTICLES);
        }
        return;
      }
    }
    
    // Get particle from pool or create new one
    let p = particlePool.pop();
    if (!p) {
      p = createParticleObject();
      particleCreationCount++;
    } else {
      particleReuseCount++;
    }
    
    // Reset particle properties
    p.x = 0; p.y = 0; p.vx = 0; p.vy = 0; p.rot = 0; p.vrot = 0;
    p.scale = 1; p.opacity = 1; p.life = 1; p.initialLife = 1;
    p.duration = 0; p.size = 0; p.color = '#ffffff'; p.text = '';
    p.src = null; p.spriteIndex = 0; p.initialSize = 0;
    p.update = null; p.render = null; p.active = true;
    
    // Set new properties
    Object.assign(p, props);
    
    // Add metadata
    p.createdAt = performance.now();
    p.lastUsed = performance.now();
    
    activeParticles.push(p);
    
    // Debug logging for smoke particles
    if (props.render === renderSmoke && Math.random() < 0.02) { // 2% chance to log
      console.log('Smoke particle added:', {
        x: props.x, y: props.y, size: props.size, life: props.life,
        poolSize: particlePool.length, activeCount: activeParticles.length
      });
    }
  }

  function chooseToken(){
    const r = Math.random();
    if(r < 0.50) return { type:'keko', mode:'text', text:'كيكو' };
    if(r < 0.80) return { type:'smirk', mode:'text', text:'😝' };
    const stars = ['🦗','👎🏿','👎🏿'];
    return { type:'emoji', mode:'text', text: stars[(Math.random()*stars.length)|0] };
  }

  function renderText(p, ctx) {
    ctx.fillStyle = p.color;
    ctx.font = `900 ${p.size}px ui-rounded, system-ui, sans-serif`;
    ctx.fillText(p.text, 0, 0);
  }
  function renderImage(p, ctx) { ctx.drawImage(p.src, -p.size/2, -p.size/2, p.size, p.size); }
  function renderSmoke(p, ctx) {
    const sprite = smokeSprites[p.spriteIndex || 0];
    const s = p.size;
    ctx.drawImage(sprite, -s/2, -s/2, s, s);
  }

  function updateFall(p, dt) {
    const elapsed = (p.initialLife - p.life) * 1000;
    const progress = Math.min(1, elapsed / p.duration);
    p.x = p.startX + p.endX * progress;
    p.y = p.startY + p.endY * progress;
    p.rot += p.vrot * dt;
    p.life -= dt / (p.duration / 1000);
  }
  function updatePop(p, dt) {
    const elapsed = (p.initialLife - p.life) * 1000;
    const progress = Math.min(1, elapsed / p.duration);
    p.scale = progress;
    p.opacity = 1 - Math.pow(progress, 3);
    p.life -= dt / (p.duration / 1000);
  }
  function updateBounce(p, dt) {
    const g = prefersReduced ? 10 : 600;
    const bounce = 0.6;
    const fric = 0.996;
    p.vy += g * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= fric;
    const floorY = viewH - p.size/2;
    const leftX = p.size/2;
    const rightX = viewW - p.size/2;
    if (p.y > floorY) { p.y = floorY; p.vy *= -bounce; p.vx *= 0.96; }
    if (p.x < leftX || p.x > rightX) { p.vx *= -bounce; p.x = Math.min(Math.max(p.x, leftX), rightX); }
    p.life -= dt * 0.5;
  }

  function rainBurst(x,y, token){
    const base = 22 + (Math.random()*10|0);
    const total = Math.max(12, Math.round(base * quality.density));
    for(let i=0;i<total;i++){
      const isImg = token.mode === 'img';
      const pSize = isImg ? rand(36, 64) : rand(18, 36);
      addParticle({
        x, y, startX:x, startY:y, endX:rand(-160,160), endY:rand(120,300),
        size:pSize, color:pickColor(), text:token.text, src:token.src,
        life:1, initialLife:1, duration: prefersReduced ? 200 : rand(700,1200),
        rot:0, vrot:rand(-5,5), update:updateFall, render:isImg?renderImage:renderText
      });
    }
  }
  function bouncyFloor(x,y, token){
    const base = 12 + (Math.random()*6|0);
    const total = Math.max(6, Math.round(base * quality.density));
    for(let i=0;i<total;i++){
      const isImg = token.mode === 'img';
      const pSize = isImg ? rand(34,56) : rand(18,30);
      addParticle({
        x, y, vx:rand(-120,120), vy:rand(-80,-180),
        size:pSize, color:pickColor(), text:token.text, src:token.src,
        life:rand(1.8,2.4), update:updateBounce, render:isImg?renderImage:renderText
      });
    }
  }
  function popEffect(x,y, token, count, life, sizeMin, sizeMax){
    for(let i=0;i<count;i++){
      const isImg = token.mode === 'img';
      const pSize = rand(sizeMin, sizeMax);
      addParticle({
        x: x + rand(-70,70), y: y + rand(-40,40),
        size:pSize, color:pickColor(), text:token.text, src:token.src,
        life:1, initialLife:1, duration:life, scale:0, update:updatePop,
        render:isImg?renderImage:renderText
      });
    }
  }
  function spawnParrots(x,y,n){
    popEffect(x, y, {type:'parrot', mode:'text', text:'🦜'},
      Math.max(6, Math.round((n || 10) * quality.density)), 900, 22, 32);
  }
  function spark(x,y){
    addParticle({
      x, y, size:8, color:'rgba(255,255,255,.8)', life:1, initialLife:1, duration:120, scale:0,
      update:updatePop,
      render:(p, ctx)=>{ ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(0,0,p.size/2,0,Math.PI*2); ctx.fill(); }
    });
  }

  function curtainDrop(){
    const rows = 3, cols = 6;
    const w = viewW/(cols+1), h = viewH/(rows+1);
    const emojis = ['😛','🦗','👎🏿','😝'];
    for(let r=1;r<=rows;r++){
      for(let c=1;c<=cols;c++){
        const tk = { type:'emoji', mode:'text', text: emojis[(Math.random()*emojis.length)|0] };
        addParticle({
          x:w*c, y:-20, startX:w*c, startY:-20, endX:rand(-16,16), endY:(h*r + rand(16,40)) + 20,
          size:26, color:pickColor(), text:tk.text, life:1, initialLife:1,
          duration: prefersReduced?160:rand(600,1000), rot:0, vrot:rand(-2,2),
          update:updateFall, render:renderText
        });
      }
    }
  }
  function emojiGeyser(){ bouncyFloor(viewW/2, viewH-30, {type:'smirk', mode:'text', text:'😝'}); }
  function confettiColumns(){
    const cols = 4, gap = viewW/(cols+1);
    for(let c=1;c<=cols;c++) rainBurst(gap*c, 20, {type:'emoji', mode:'text', text:'👎🏿'});
  }
  function randomEffect(x,y){
    const token = chooseToken();
    (Math.random()<0.5 ? bouncyFloor : rainBurst)(x,y, token);
    if(token.type==='keko') playSfx('keko');
    if(token.type==='keko') spawnParrots(x,y);
  }
  
  function triggerScreenShake(duration = 280) {
    if (prefersReduced) {
      flash.classList.add('show');
      setTimeout(() => flash.classList.remove('show'), duration / 2);
    } else {
      play.classList.add('shake');
      setTimeout(() => play.classList.remove('shake'), duration);
    }
  }

  function chaos(){
    let t = 0;
    const maxBursts = quality.heavy ? 8 : 6;
    const spam = setInterval(()=>{
      const rx = rand(40, viewW-40);
      const ry = rand(40, viewH-40);
      randomEffect(rx, ry);
      if(++t>=maxBursts) clearInterval(spam);
    }, 160);
    triggerScreenShake();
    haptic();
  }

  const car = {
    x:0, y:0, theta:-0.4, u:360, v:0, rYaw:0,
    a:70, b:70, invM:1/1800, invIz:1/90000, CfBase:18000, CrBase:12000, steerMax:0.75,
    mu:1.15, Cf:18000, Cr:10200, side:1, targetBeta:0.8, targetSpeed:500,
    nextSwitch:0, nextEbrake:0, ebrakeUntil:0, bodyRoll: 0
  };
  function clamp(t, lo, hi){ return t<lo?lo:(t>hi?hi:t); }
  function norm(a){ while(a>Math.PI) a-=Math.PI*2; while(a<-Math.PI) a+=Math.PI*2; return a; }

  function selectRandomDriftImage() {
    const useDrift2 = Math.random() < 0.5;
    currentDriftImage = useDrift2 ? 'drift2.png' : 'drift.png';
    const meta = IMAGE_ANCHORS[currentDriftImage] || { smokeFrom: 'right' };
    driftImageSide = meta.smokeFrom;     // 'left' or 'right'
    if (drifter) drifter.src = currentDriftImage;
  }

  function initCar(ts){
    // Select random drift image for this session
    selectRandomDriftImage();
    
    car.x = viewW*0.25; car.y = viewH*0.7; car.theta = -0.4; car.u = 360; car.v = 0; car.rYaw = 0;
    car.Cf = car.CfBase; car.Cr = car.CrBase*0.85; car.mu = 1.15;
    car.side = Math.random()<0.5 ? -1 : 1;
    car.targetBeta = car.side*rand(0.65,1.05);
    car.targetSpeed = rand(420,560);
    car.nextSwitch = ts + rand(700,1400);
    car.nextEbrake = ts + rand(900,2000);
    car.ebrakeUntil = 0;
  }

  function stepCar(dt, ts){
    if (ts > car.nextSwitch){
      car.side = Math.random()<0.5 ? -1 : 1;
      car.targetBeta = car.side*rand(0.65,1.05);
      car.targetSpeed = rand(420,560);
      car.nextSwitch = ts + rand(700,1400);
    }
    if (ts > car.nextEbrake){
      car.ebrakeUntil = ts + rand(180,320);
      car.nextEbrake = ts + rand(900,2000);
    }

    const beta = norm(Math.atan2(car.v, car.u));
    let delta = clamp(-1.4*(beta - car.targetBeta) - 0.15*car.rYaw, -car.steerMax, car.steerMax);
    if(ts < car.ebrakeUntil){ car.mu = 0.85; car.Cr = car.CrBase*0.35; }
    else { car.mu = 1.15; car.Cr = car.CrBase*0.85; }

    const af = norm(Math.atan2(car.v + car.a*car.rYaw, Math.max(1,car.u)) - delta);
    const ar = norm(Math.atan2(car.v - car.b*car.rYaw, Math.max(1,car.u)));

    let Fyf = -car.Cf * af;
    let Fyr = -car.Cr * ar;
    const FyMaxF = car.mu*12000, FyMaxR = car.mu*9000;
    Fyf = clamp(Fyf, -FyMaxF, FyMaxF);
    Fyr = clamp(Fyr, -FyMaxR, FyMaxR);

    const speed2 = car.u*car.u + car.v*car.v;
    const target2 = car.targetSpeed*car.targetSpeed;
    let ax = speed2 < target2 ? 280 : -180;
    if(ts < car.ebrakeUntil) ax -= 120;

    car.u += dt*(ax + car.rYaw*car.v + (-Fyf*Math.sin(delta))*car.invM);
    car.v += dt*((Fyr + Fyf*Math.cos(delta))*car.invM - car.rYaw*car.u);
    car.rYaw += dt*((car.a*Fyf*Math.cos(delta) - car.b*Fyr)*car.invIz);
    
    // Body Roll Simulation
    const lateralForce = Fyr + Fyf * Math.cos(delta);
    const targetRoll = -clamp(lateralForce * 0.000005, -0.15, 0.15);
    car.bodyRoll += (targetRoll - car.bodyRoll) * dt * 8;


    const ct = Math.cos(car.theta), st = Math.sin(car.theta);
    const wx = car.u*ct - car.v*st, wy = car.u*st + car.v*ct;
    car.x += wx*dt; car.y += wy*dt; car.theta += car.rYaw*dt;

    const m = 40;
    let wallHit = false;
    if(car.x < m || car.x > viewW - m){
      car.x = Math.max(m, Math.min(viewW - m, car.x));
      const nx = car.x < viewW*0.5 ? 1 : -1;
      const rwx = -wx*0.6, rwy = wy;
      car.u = rwx*ct + rwy*st; car.v = -rwx*st + rwy*ct; car.rYaw += 1.0*nx;
      wallHit = true;
    }
    if(car.y < m || car.y > viewH - m){
      car.y = Math.max(m, Math.min(viewW - m, car.y));
      const ny = car.y < viewH*0.5 ? 1 : -1;
      const rwx = wx, rwy = -wy*0.6;
      car.u = rwx*ct + rwy*st; car.v = -rwx*st + rwy*ct; car.rYaw -= 0.8*ny;
      wallHit = true;
    }
    if (wallHit) triggerScreenShake(150);

    // Smoke and Tire Marks
    if(!prefersReduced){
      const slip = Math.abs(ar);
      // Lower threshold for more consistent smoke generation
      if(slip > 0.25 || ts < car.ebrakeUntil){
        // Tire mark points from calibrated wheel centers
        const ct = Math.cos(car.theta), st = Math.sin(car.theta);

        // local to world helper
        function toWorld(local){
          return {
            x: car.x + local.x * ct - local.y * st,
            y: car.y + local.x * st + local.y * ct
          };
        }
        const worldLeft  = toWorld(wheelLocalLeft);
        const worldRight = toWorld(wheelLocalRight);

        // Tire marks
        if (lastTirePoints.left) {
          tireMarkCtx.strokeStyle = 'rgba(255,255,255,0.04)';
          tireMarkCtx.lineWidth = 2;
          tireMarkCtx.beginPath();
          tireMarkCtx.moveTo(lastTirePoints.left.x, lastTirePoints.left.y);
          tireMarkCtx.lineTo(worldLeft.x, worldLeft.y);
          tireMarkCtx.stroke();

          tireMarkCtx.beginPath();
          tireMarkCtx.moveTo(lastTirePoints.right.x, lastTirePoints.right.y);
          tireMarkCtx.lineTo(worldRight.x, worldRight.y);
          tireMarkCtx.stroke();
        }
        lastTirePoints.left = worldLeft;
        lastTirePoints.right = worldRight;
        
        // Smoke
        const strong = slip > 0.5; // Lowered from 0.6
        const veryStrong = slip > 0.7; // Lowered from 0.8
        const baseCount = strong ? (veryStrong ? 3 : 2) : 1; // Increased base counts
        const count = Math.max(1, Math.floor(baseCount * quality.density)); // Ensure at least 1 particle
        
        const rearAxleVelX = wx - st * car.b * car.rYaw;
        const rearAxleVelY = wy + ct * car.b * car.rYaw;
        
        // 25% bigger than before and proportional to car width
        const smokeSizeBase = carWidthPx * 0.065;

        // choose calibrated wheel for this image
        const smokeOrigin = (driftImageSide === 'right') ? worldRight : worldLeft;

        // Debug smoke generation (only log occasionally to avoid spam)
        if (Math.random() < 0.01) { // 1% chance to log
          console.log('Smoke generation:', {
            slip: slip.toFixed(3),
            count: count,
            quality: quality.density,
            ebrake: ts < car.ebrakeUntil,
            smokeOrigin: smokeOrigin,
            driftImage: currentDriftImage,
            side: driftImageSide
          });
        }
        
        // Visual debug: Show slip indicator on screen
        if (slip > 0.2) { // Show indicator when approaching smoke threshold
          mainCtx.save();
          mainCtx.fillStyle = `rgba(255, ${slip > 0.25 ? '255' : '128'}, 0, 0.6)`;
          mainCtx.font = '12px monospace';
          mainCtx.fillText(`Slip: ${slip.toFixed(2)}`, 10, 30);
          mainCtx.restore();
        }

        for (let i = 0; i < count; i++) {
          const spriteIndex = Math.floor(Math.random() * smokeSprites.length);
          const baseSize = smokeSizeBase * (veryStrong ? 1.3 : strong ? 1.05 : 0.85);
          const baseSmokeVx = -rearAxleVelX, baseSmokeVy = -rearAxleVelY;
          const speedScale = rand(0.12, 0.28);
          const angle = rand(-0.5, 0.5);
          const c = Math.cos(angle), s = Math.sin(angle);
          const vx = (baseSmokeVx * c - baseSmokeVy * s) * speedScale;
          const vy = (baseSmokeVx * s + baseSmokeVy * c) * speedScale;

          addParticle({
            x: smokeOrigin.x, y: smokeOrigin.y,
            vx, vy,
            size: baseSize, life: rand(1.4, 2.2), opacity: rand(0.35, 0.6),
            rot: rand(0, Math.PI*2), vrot: rand(-1.5, 1.5),
            spriteIndex, initialSize: baseSize,
            update: function(p, dt){
              const air = 0.985, buoy = -10;
              p.vx *= air; p.vy = (p.vy + buoy * dt) * air;
              p.x += p.vx * dt; p.y += p.vy * dt;
              p.rot += p.vrot * dt;
              p.life -= dt * 0.8;
              p.opacity = p.life * 0.7;
              p.scale = 1 + (1 - p.life) * 1.2;
              p.size = p.initialSize * p.scale;
            },
            render: renderSmoke
          });
          
          // Add "وييييي" text particles that spawn from smoke
          if (Math.random() < 0.3) { // 30% chance to spawn text with each smoke particle
            const textParticle = {
              x: smokeOrigin.x + rand(-20, 20),
              y: smokeOrigin.y + rand(-20, 20),
              vx: rand(-80, 80),
              vy: rand(-120, -60),
              size: rand(16, 32),
              color: pickColor(),
              text: 'وييييي',
              life: rand(1.5, 2.5),
              rot: rand(-0.5, 0.5),
              vrot: rand(-2, 2),
              scale: 1,
              opacity: rand(0.7, 1.0),
              update: function(p, dt) {
                // Physics update for text particles
                const gravity = 200;
                const airResistance = 0.98;
                
                p.vy += gravity * dt;
                p.vx *= airResistance;
                p.vy *= airResistance;
                
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.rot += p.vrot * dt;
                
                // Life and visual effects
                p.life -= dt * 0.6;
                p.opacity = p.life * 0.8;
                p.scale = 1 + (1 - p.life) * 0.5;
                
                // Bounce off ground
                if (p.y > viewH - p.size/2) {
                  p.y = viewH - p.size/2;
                  p.vy *= -0.6;
                  p.vx *= 0.8;
                }
                
                // Bounce off walls
                if (p.x < p.size/2) {
                  p.x = p.size/2;
                  p.vx *= -0.7;
                }
                if (p.x > viewW - p.size/2) {
                  p.x = viewW - p.size/2;
                  p.vx *= -0.7;
                }
              },
              render: function(p, ctx) {
                ctx.save();
                ctx.globalAlpha = p.opacity;
                ctx.fillStyle = p.color;
                ctx.font = `bold ${p.size * p.scale}px ui-rounded, system-ui, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.text, 0, 0);
                
                // Add glow effect
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 8;
                ctx.fillText(p.text, 0, 0);
                ctx.restore();
              }
            };
            
            addParticle(textParticle);
          }
        }
      } else {
        lastTirePoints.left = null;
        lastTirePoints.right = null;
      }
    }

    // Push nearby particles using squared distance
    const R = 110, R2 = R*R;
    for (const p of activeParticles) {
      if (!p.active) continue;
      const dx = p.x - car.x, dy = p.y - car.y;
      const d2 = dx*dx + dy*dy;
      if (d2 < R2) {
        const d = Math.sqrt(Math.max(d2, 1e-6));
        const push = (R - d) * 0.08;
        const inv = 1 / d;
        p.x += dx * inv * push;
        p.y += dy * inv * push;
      }
    }

    drifter.style.transform = `translate(${car.x - carWidthPx/2}px, ${car.y - carHeightPx/2 + car.bodyRoll * 10}px) rotate(${car.theta + car.bodyRoll * 0.2}rad)`;
  }

  // Enhanced Performance Management
  let emaDt = 1/60;
  let lastAdapt = 0;
  let targetFPS = 60;
  let currentFPS = 60;
  let frameTimeHistory = [];
  let lastFrameTime = 0;
  
  // Adaptive frame rate control
  function updateFrameRate(ts) {
    if (lastFrameTime > 0) {
      const frameTime = ts - lastFrameTime;
      frameTimeHistory.push(frameTime);
      
      // Keep only last 60 frames for averaging
      if (frameTimeHistory.length > 60) {
        frameTimeHistory.shift();
      }
      
      // Calculate current FPS
      const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
      currentFPS = 1000 / avgFrameTime;
      
      // Adjust target FPS based on performance
      if (currentFPS < 45 && targetFPS > 30) {
        targetFPS = Math.max(30, targetFPS - 5);
        console.log(`Performance drop detected. Reducing target FPS to ${targetFPS}`);
      } else if (currentFPS > 58 && targetFPS < 60) {
        targetFPS = Math.min(60, targetFPS + 2);
      }
    }
    lastFrameTime = ts;
  }
  
  // Canvas optimization
  function optimizeCanvasContexts() {
    // Enable hardware acceleration hints
    canvases.forEach(canvas => {
      const ctx = canvas.getContext('2d', {
        alpha: true,
        antialias: false, // Disable for better performance
        willReadFrequently: false // Hint that we won't read pixel data
      });
      
      // Set composite operation for better blending
      ctx.globalCompositeOperation = 'source-over';
      
      // Optimize text rendering
      ctx.textRenderingOptimization = 'optimizeSpeed';
    });
    
    console.log('Canvas contexts optimized for performance');
  }
  
  function initStars() {
    stars = [];
    for (let i = 0; i < 100; i++) {
      stars.push({
        x: Math.random() * viewW,
        y: Math.random() * viewH,
        size: Math.random() * 1.5 + 0.5,
        opacity: Math.random() * 0.5 + 0.2
      });
    }
  }

  function drawBackground(dt) {
    bgCtx.clearRect(0, 0, viewW, viewH);
    bgCtx.fillStyle = '#0b0d12';
    bgCtx.fillRect(0,0,viewW,viewH);

    // Update and draw stars
    const speed = Math.sqrt(car.u * car.u + car.v * car.v);
    const parallax = speed * dt * 0.05;

    stars.forEach(star => {
      star.x -= parallax;
      if (star.x < 0) star.x += viewW;
      
      bgCtx.beginPath();
      bgCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
      bgCtx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
      bgCtx.fill();
    });
  }

  function mainLoop(ts) {
    // Update frame rate tracking
    updateFrameRate(ts);
    frameCount++;
    
    const dt = lastTime ? Math.min(0.05, (ts - lastTime) / 1000) : 0;
    lastTime = ts;

    if (!paused) {
      stepCar(dt, ts);

      // Fade tire marks
      tireMarkCtx.fillStyle = 'rgba(11, 13, 18, 0.02)';
      tireMarkCtx.fillRect(0, 0, viewW, viewH);

      // Update particles with enhanced memory management
      for (let i = activeParticles.length - 1; i >= 0; i--) {
        const p = activeParticles[i];
        if (p.update) p.update(p, dt);
        if (p.life <= 0) {
          p.active = false;
          p.lastUsed = ts;
          p.useCount++;
          particlePool.push(p);
          activeParticles.splice(i, 1);
        }
      }

      emaDt = emaDt * 0.9 + dt * 0.1;
      
      if (ts - lastAdapt > 1200) {
        adjustParticleDensity();
        lastAdapt = ts;
      }
      
      // Memory cleanup every 60 frames (1 second at 60fps)
      if (frameCount % 60 === 0) {
        cleanupMemory();
      }
      
      // Update performance overlay every 30 frames
      if (frameCount % 30 === 0) {
        updatePerformanceOverlay();
      }
    }

    // Drawing with performance optimization
    drawBackground(dt);
    
    mainCtx.clearRect(0, 0, viewW, viewH);
    mainCtx.textAlign = 'center';
    mainCtx.textBaseline = 'middle';
    
    // Batch render particles for better performance
    const visibleParticles = activeParticles.filter(p => 
      p.x >= -p.size && p.x <= viewW + p.size && 
      p.y >= -p.size && p.y <= viewH + p.size
    );
    
    for (const p of visibleParticles) {
      if (!p.render) continue;
      mainCtx.save();
      mainCtx.translate(p.x, p.y);
      mainCtx.rotate(p.rot);
      mainCtx.scale(p.scale, p.scale);
      mainCtx.globalAlpha = p.opacity;
      p.render(p, mainCtx);
      mainCtx.restore();
    }

    // Adaptive frame rate control
    const frameDelay = 1000 / targetFPS;
    const elapsed = ts - lastFrameTime;
    
    if (elapsed >= frameDelay) {
      requestAnimationFrame(mainLoop);
    } else {
      setTimeout(() => requestAnimationFrame(mainLoop), frameDelay - elapsed);
    }
  }

  function setPaused(flag){
    if (paused === flag) return;
    paused = flag;
    play.classList.toggle('paused', paused);
    announce(paused ? 'تم الإيقاف المؤقت.' : 'تم الاستئناف.');
  }

  function resetScene(){
    activeParticles.forEach(p => {
      p.active = false;
      particlePool.push(p);
    });
    activeParticles.length = 0;
    tireMarkCtx.clearRect(0,0,viewW,viewH);
    lastTirePoints = { left: null, right: null };

    // Select a new random drift image for each reset
    selectRandomDriftImage();
    initCar(performance.now());
    smirk.classList.add('show'); setTimeout(()=> smirk.classList.remove('show'), 700);
    curtainDrop();
    setTimeout(()=>confettiColumns(), 300);
  }

  function startShow(){
    try {
      // Immediately hide the wrap to prevent button from persisting
      wrap.classList.add('hidden');
      
      // Show a brief loading confirmation before transitioning
      loading.classList.remove('hidden');
      updateLoadingProgress(100, 'تم التحميل!');
      
      setTimeout(() => {
        loading.classList.add('hidden');
        
        // Show play area with smooth transition
        play.style.display = 'block';
        setTimeout(() => {
          play.classList.add('visible');
          
          // Initialize enhanced systems
          initializeParticlePool();
          optimizeCanvasContexts();
          createPerformanceOverlay();
          resizeAllCanvases();
          unlockAudio();
          initCar(performance.now());
          
          // Staggered animations for better visual flow
          smirk.classList.add('show'); 
          setTimeout(()=> smirk.classList.remove('show'), 700);
          
          curtainDrop();
          setTimeout(()=>randomEffect(viewW/2, viewH/2), 140);
          setTimeout(()=>emojiGeyser(), 300);
          setTimeout(()=>confettiColumns(), 520);
          
          lastTime = performance.now();
          announce('التحكم: Enter أو مسافة للتأثير. P إيقاف/استئناف. M كتم. R إعادة تعيين. I تبديل الصورة. S اختبار الدخان. Pinch to zoom on mobile.');
          requestAnimationFrame(mainLoop);
          play.focus();
        }, 50); // Short delay to ensure display:block is registered before transition
        
      }, 300);
      
    } catch (error) {
      console.error('Error in startShow function:', error);
      announce('حدث خطأ في بدء العرض. يرجى تحديث الصفحة.');
      // visible toast so the user actually sees it
      const msg = document.createElement('div');
      msg.style.cssText = "position:fixed;left:16px;right:16px;bottom:16px;background:#e11d48;color:#fff;padding:12px 16px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.25);z-index:99999;font-weight:700;text-align:center";
      msg.textContent = "حدث خطأ عند البدء. حدّث الصفحة.";
      document.body.appendChild(msg);
    }
  }

  window.addEventListener('resize', resizeAllCanvases, { passive:true });
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){
      if(!paused){ autoPaused = true; setPaused(true); }
      sfxKeko.pause();
    } else if (autoPaused){
      setPaused(false); autoPaused = false;
    }
  });

  window.addEventListener('pointerdown', unlockAudio, { once:true, passive:true });

  // Enhanced initialization with progressive loading
  function initializeInterface() {
    // Show skeleton loading first
    showSkeleton();
    
    // Simulate progressive loading
    let progress = 0;
    const loadingInterval = setInterval(() => {
      progress += Math.random() * 15 + 5;
      if (progress >= 100) {
        progress = 100;
        clearInterval(loadingInterval);
        
        // Complete loading sequence
        setTimeout(() => {
          loading.classList.add('hidden');
          hideSkeleton();
          wrap.style.display = 'grid';
          wrap.classList.add('entering');
          
          setTimeout(() => {
            wrap.classList.remove('entering');
          }, 800);
        }, 300);
      }
      updateLoadingProgress(progress, `جاري التحميل... ${Math.round(progress)}%`);
    }, 100);
  }

  // Performance monitoring overlay
  function createPerformanceOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'performanceOverlay';
    overlay.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 12px;
      z-index: 1000;
      display: none;
    `;
    
    document.body.appendChild(overlay);
    
    // Toggle with 'P' key (when not paused)
    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'p' && e.ctrlKey) {
        overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';
      }
    });
    
    return overlay;
  }

  // Update performance overlay
  function updatePerformanceOverlay() {
    const overlay = document.getElementById('performanceOverlay');
    if (overlay && overlay.style.display !== 'none') {
      overlay.innerHTML = `
        FPS: ${Math.round(currentFPS)}<br>
        Target: ${targetFPS}<br>
        Particles: ${activeParticles.length}<br>
        Pool: ${particlePool.length}<br>
        Memory: ${Math.round(memoryUsage)}MB
      `;
    }
  }
  
  // Initialize the interface
  initializeInterface();

  // NEW: robust start handler (pointerup + click) with guard
  let started = false;
  function startShowGuard(e){
    if (started) return;
    started = true;
    if (e && e.preventDefault) e.preventDefault();
    startShow();
  }
  startBtn.addEventListener('pointerup', startShowGuard, { once:true });
  startBtn.addEventListener('click', startShowGuard, { once:true });

  // Fallback: If loading spinner persists for too long, show start button
  setTimeout(() => {
    if (loading.classList.contains('hidden') === false) {
      console.warn('Loading spinner persisted too long, showing start button as fallback');
      loading.style.display = 'none';
      wrap.style.display = 'grid';
    }
  }, 5000);

  // Enhanced Touch Controls and Gesture Recognition
  let touchStartTime = 0;
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartDistance = 0;
  let isMultiTouch = false;
  let lastPinchDistance = 0;

  play.addEventListener('pointerdown', e=>{
    pressing = true;
    touchStartTime = performance.now();
    touchStartX = e.clientX;
    touchStartY = e.clientY;
    
    const rect = mainCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    
    // Enhanced visual feedback
    spark(x,y); 
    randomEffect(x,y);
    
    // Create ripple effect
    createRippleEffect(x, y);
    
    // Enhanced haptic feedback with different patterns
    if (navigator.vibrate) {
      const pattern = e.pointerType === 'touch' ? [20, 15, 25] : [30, 20, 30];
      navigator.vibrate(pattern);
    }
    
    pressTimer = setTimeout(()=>{ chaos(); }, 500);
  }, { passive:true });

  // Multi-touch gesture support
  play.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
      isMultiTouch = true;
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      touchStartDistance = Math.sqrt(
        Math.pow(touch2.clientX - touch1.clientX, 2) + 
        Math.pow(touch2.clientY - touch1.clientY, 2)
      );
      lastPinchDistance = touchStartDistance;
    }
  }, { passive: true });

  play.addEventListener('touchmove', e => {
    if (isMultiTouch && e.touches.length === 2) {
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const currentDistance = Math.sqrt(
        Math.pow(touch2.clientX - touch1.clientX, 2) + 
        Math.pow(touch2.clientY - touch1.clientY, 2)
      );
      
      // Pinch to zoom effect (affects particle density)
      const pinchDelta = currentDistance - lastPinchDistance;
      if (Math.abs(pinchDelta) > 20) {
        if (pinchDelta > 0) {
          // Zoom in - increase particle density
          quality.density = Math.min(1.0, quality.density * 1.1);
          maxParticles = Math.min(BASE_MAX, Math.floor(maxParticles * 1.05));
        } else {
          // Zoom out - decrease particle density
          quality.density = Math.max(0.3, quality.density * 0.9);
          maxParticles = Math.max(50, Math.floor(maxParticles * 0.95));
        }
        lastPinchDistance = currentDistance;
        
        // Visual feedback for pinch gesture
        const centerX = (touch1.clientX + touch2.clientX) / 2;
        const centerY = (touch1.clientY + touch2.clientY) / 2;
        createPinchFeedback(centerX, centerY, pinchDelta > 0 ? 'zoom-in' : 'zoom-out');
      }
    }
  }, { passive: true });

  play.addEventListener('touchend', e => {
    if (e.touches.length < 2) {
      isMultiTouch = false;
    }
  }, { passive: true });
  
  // Enhanced ripple effect for interactions
  function createRippleEffect(x, y) {
    const ripple = document.createElement('div');
    ripple.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: var(--z-tooltip);
      animation: rippleExpand 0.6s ease-out forwards;
    `;
    
    play.appendChild(ripple);
    
    setTimeout(() => {
      if (ripple.parentNode) {
        ripple.parentNode.removeChild(ripple);
      }
    }, 600);
  }

  // Pinch gesture feedback
  function createPinchFeedback(x, y, type) {
    const feedback = document.createElement('div');
    feedback.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: var(--z-tooltip);
      font-size: 24px;
      color: ${type === 'zoom-in' ? '#10b981' : '#f59e0b'};
      text-shadow: 0 2px 8px rgba(0,0,0,0.5);
      animation: pinchFeedback 0.8s ease-out forwards;
    `;
    feedback.textContent = type === 'zoom-in' ? '🔍+' : '🔍-';
    
    play.appendChild(feedback);
    
    setTimeout(() => {
      if (feedback.parentNode) {
        feedback.parentNode.removeChild(feedback);
      }
    }, 800);
  }

  // Enhanced visual feedback system
  function createEnhancedFeedback(x, y, type, intensity = 1) {
    // Particle burst
    const particleCount = Math.floor(8 * intensity);
    for (let i = 0; i < particleCount; i++) {
      const angle = (i / particleCount) * Math.PI * 2;
      const speed = 60 + Math.random() * 40;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      
      addParticle({
        x: x + Math.random() * 20 - 10,
        y: y + Math.random() * 20 - 10,
        vx, vy,
        size: rand(8, 16),
        color: type === 'success' ? '#10b981' : type === 'warning' ? '#f59e0b' : pickColor(),
        life: rand(0.8, 1.5),
        update: updateBounce,
        render: (p, ctx) => {
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(0, 0, p.size/2, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }
    
    // Screen flash effect
    if (intensity > 0.7) {
      flash.classList.add('show');
      setTimeout(() => flash.classList.remove('show'), 100);
    }
  }

  play.addEventListener('pointermove', e=>{
    if(!pressing) return;
    const now = performance.now(); if(now - lastTrail < 50) return; lastTrail = now;
    const rect = mainCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const chs = ['✦','✧','•']; const ch = chs[(Math.random()*chs.length)|0];
    addParticle({ x, y, size: 14, color: pickColor(), text: ch, life: 1, initialLife: 1, duration: 700, scale: 0, update: updatePop, render: renderText });
  }, { passive:true });

  play.addEventListener('pointerup', ()=>{ pressing = false; clearTimeout(pressTimer); pressTimer = null; }, { passive:true });
  play.addEventListener('pointercancel', ()=>{ pressing = false; clearTimeout(pressTimer); pressTimer = null; }, { passive:true });

  play.addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if(k==='enter' || k===' '){
      randomEffect(viewW/2, viewH/2);
      createEnhancedFeedback(viewW/2, viewH/2, 'success', 0.8);
      e.preventDefault();
    } else if(k==='p'){
      setPaused(!paused); 
      createEnhancedFeedback(viewW/2, viewH/2, paused ? 'warning' : 'success', 0.6);
      e.preventDefault();
    } else if(k==='m'){
      audio.muted = !audio.muted;
      if (bgMusic) { bgMusic.muted = audio.muted; }
      announce(audio.muted ? 'تم كتم الصوت.' : 'تم تشغيل الصوت.');
      createEnhancedFeedback(viewW/2, viewH/2, audio.muted ? 'warning' : 'success', 0.7);
      e.preventDefault();
    } else if(k==='r'){
      resetScene(); 
      createEnhancedFeedback(viewW/2, viewH/2, 'success', 1.0);
      e.preventDefault();
    } else if(k==='i'){
      // Manual image switch for testing
      selectRandomDriftImage();
      announce(`Switched to ${currentDriftImage} (smoke from ${driftImageSide})`);
      createEnhancedFeedback(viewW/2, viewH/2, 'info', 0.5);
      e.preventDefault();
    } else if(k==='s'){
      // Manual smoke test
      const testX = car.x + Math.cos(car.theta) * 50;
      const testY = car.y + Math.sin(car.theta) * 50;
      
      // Force add some smoke particles for testing
      for (let i = 0; i < 5; i++) {
        addParticle({
          x: testX + Math.random() * 20 - 10,
          y: testY + Math.random() * 20 - 10,
          vx: (Math.random() - 0.5) * 50,
          vy: (Math.random() - 0.5) * 50,
          size: 40, life: 2.0, opacity: 0.6,
          rot: Math.random() * Math.PI * 2, vrot: (Math.random() - 0.5) * 3,
          spriteIndex: Math.floor(Math.random() * smokeSprites.length),
          initialSize: 40,
          update: function(p, dt){
            const air = 0.985, buoy = -10;
            p.vx *= air; p.vy = (p.vy + buoy * dt) * air;
            p.x += p.vx * dt; p.y += p.vy * dt;
            p.rot += p.vrot * dt;
            p.life -= dt * 0.8;
            p.opacity = p.life * 0.7;
            p.scale = 1 + (1 - p.life) * 1.2;
            p.size = p.initialSize * p.scale;
          },
          render: renderSmoke
        });
        
        // Also add "وييييي" text particles for manual test
        addParticle({
          x: testX + Math.random() * 30 - 15,
          y: testY + Math.random() * 30 - 15,
          vx: rand(-100, 100),
          vy: rand(-150, -80),
          size: rand(20, 36),
          color: pickColor(),
          text: 'وييييي',
          life: rand(2.0, 3.0),
          rot: rand(-0.8, 0.8),
          vrot: rand(-3, 3),
          scale: 1,
          opacity: rand(0.8, 1.0),
          update: function(p, dt) {
            // Physics update for text particles
            const gravity = 200;
            const airResistance = 0.98;
            
            p.vy += gravity * dt;
            p.vx *= airResistance;
            p.vy *= airResistance;
            
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.rot += p.vrot * dt;
            
            // Life and visual effects
            p.life -= dt * 0.5;
            p.opacity = p.life * 0.8;
            p.scale = 1 + (1 - p.life) * 0.5;
            
            // Bounce off ground
            if (p.y > viewH - p.size/2) {
              p.y = viewH - p.size/2;
              p.vy *= -0.6;
              p.vx *= 0.8;
            }
            
            // Bounce off walls
            if (p.x < p.size/2) {
              p.x = p.size/2;
              p.vx *= -0.7;
            }
            if (p.x > viewW - p.size/2) {
              p.x = viewW - p.size/2;
              p.vx *= -0.7;
            }
          },
          render: function(p, ctx) {
            ctx.save();
            ctx.globalAlpha = p.opacity;
            ctx.fillStyle = p.color;
            ctx.font = `bold ${p.size * p.scale}px ui-rounded, system-ui, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(p.text, 0, 0);
            
            // Add glow effect
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 8;
            ctx.fillText(p.text, 0, 0);
            ctx.restore();
          }
        });
      }
      announce('Manual smoke test triggered');
      createEnhancedFeedback(testX, testY, 'success', 0.9);
      e.preventDefault();
    }
  });

})();
</script>
</body>
</html>
